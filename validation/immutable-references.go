package validation

import (
	"encoding/json"
	"fmt"
)

// ContractASTsWithImmutableReferences stores the `immutableReferences`, copied from the compiled contract AST (from the combined JSON
// artifact from the monorepo. We do this because the contracts and compiled artifacts are not available in the superchain
// registry. Ex: ethereum-optimism/optimism/packages/contracts-bedrock/forge-artifacts/MIPS.sol/MIPS.json
var ContractASTsWithImmutableReferences = map[string]string{
	"AnchorStateRegistryProxy": `"immutableReferences":{"92829":[{"start":387,"length":32},{"start":828,"length":32},{"start":2296,"length":32}]}`,
	"DelayedWETHProxy":         `"immutableReferences":{"97827":[{"start":831,"length":32},{"start":4133,"length":32}]}`,
	"FaultDisputeGame":         `"immutableReferences":{"92829":[{"start":387,"length":32},{"start":828,"length":32},{"start":2296,"length":32}]}`,
	"MIPS":                     `"immutableReferences":{"85798":[{"start":178,"length":32},{"start":1771,"length":32}]}`,
}

// ImmutableReference to store the start/length of a contract's immutable references. Immutables
// are directly assigned values once or are initialized in a constructor. They are encoded in the contract bytecode,
// and the AST that is generated by the compiler has info about the offset & length within the bytecode.
type ImmutableReference struct {
	Start  int `json:"start"`
	Length int `json:"length"`
}

// Define a struct to represent the structure of the JSON data
type DeployedBytecode struct {
	Bytecode            []byte                          `json:"object"`
	ImmutableReferences map[string][]ImmutableReference `json:"immutableReferences"`
}

// initBytecodeImmutableMask returns the struct with coordinates of the immutable references in the deployed bytecode, if present
func initBytecodeImmutableMask(bytecode []byte, contractName string) (*DeployedBytecode, error) {
	parsedImmutables := map[string][]ImmutableReference{}
	refs, exists := ContractASTsWithImmutableReferences[contractName]
	if exists {
		err := json.Unmarshal([]byte(refs), &parsedImmutables)
		if err != nil {
			return nil, fmt.Errorf("unable to parse immutable references for %s: %w", contractName, err)
		}
	}
	return &DeployedBytecode{Bytecode: bytecode, ImmutableReferences: parsedImmutables}, nil
}

// maskBytecode checks for the presence of immutables in the contract, as indicated by the stored config and if present,
// masks the sections of the bytecode where immutables are stored. If immutables aren't present, the stored bytecode in the receiver is unaltered
func (deployed *DeployedBytecode) maskBytecode(contractName string) error {
	_, exists := ContractASTsWithImmutableReferences[contractName]
	if exists {
		for _, v := range deployed.ImmutableReferences {
			for _, r := range v {
				for i := r.Start; i < r.Start+r.Length; i++ {
					if i >= len(deployed.Bytecode) {
						return fmt.Errorf("immutable reference [start:%d, length: %d] extends beyond bytecode", r.Start, r.Length)
					}
					deployed.Bytecode[i] = 0
				}
			}
		}
	}
	return nil
}
